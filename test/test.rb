# frozen_string_literal: true

require 'test/unit'
require 'dotenv'
require_relative '../lib/rujira'

class UnitTest < Test::Unit::TestCase # rubocop:disable Metrics/ClassLength
  Dotenv.load

  def random_name
    Array.new(5) { ('A'..'Z').to_a.sample }.join
  end

  def env_var?(var)
    %w[true 1 yes].include?(ENV[var]&.downcase)
  end

  def test_dispatch_flow_usage # rubocop:disable Metrics/AbcSize,Metrics/MethodLength
    return unless env_var? 'RUJIRA_TEST'

    require 'date'

    now = Date.today
    before = now + 30

    project = random_name
    url = ENV.fetch('RUJIRA_URL', 'http://localhost:8080')
    client = Rujira::Client.new(url, debug: true, dispatchable: true)

    client.ServerInfo.get
    name = client.Myself.get['name']

    client.Myself.update do
      payload password: 'toor',
              displayName: 'Very Important'
    end

    client.Project.create do
      payload key: project.to_s,
              name: project.to_s,
              projectTypeKey: 'software',
              lead: name
    end
    client.Project.get project.to_s
    client.Issue.create do
      payload fields: {
        project: { key: project.to_s },
        summary: 'BOT: added a new feature.',
        description: 'This task was generated by the bot when creating changes in the repository.',
        issuetype: { name: 'Task' }
      }
      params updateHistory: true
    end

    boards = client.Board.list
    board = boards['values'].find { |b| b['type'] == 'scrum' }
    board_id = board['id']

    client.Board.get board_id

    sprint = client.Sprint.create do
      payload name: 'Bot Sprint',
              originBoardId: board_id,
              goal: 'Finish core features for release 1.0',
              autoStartStop: false
    end
    client.Sprint.issue sprint['id'], ["#{project}-1"]

    client.Sprint.replace sprint['id'] do
      payload state: 'future',
              name: 'Bot Sprint',
              originBoardId: board_id,
              goal: 'Finish core features for release 1.0',
              startDate: now,
              endDate: before,
              autoStartStop: true
    end

    update = client.Sprint.update sprint['id'] do
      payload name: "Bot Sprint #{project}"
    end

    assert_equal 'Bot Sprint', sprint['name']
    assert_equal "Bot Sprint #{project}", update['name']

    issues = client.Sprint.get_issue sprint['id']

    assert_not_empty issues['issues']

    client.Issue.get "#{project}-1"

    client.Issue.watcher "#{project}-1", name
    client.Issue.get_watchers "#{project}-1"
    client.Issue.remove_watchers "#{project}-1", 'root'
    search = client.Search.get do
      payload jql: "project = #{project} and status IN (\"To Do\", \"In Progress\") ORDER BY issuekey",
              maxResults: 10,
              startAt: 0,
              fields: %w[id key]
    end
    client.Issue.add_comment "#{project}-1" do
      payload body: 'Adding a new comment'
    end
    client.Issue.attachments "#{project}-1", '/tmp/test.file'
    client.Issue.edit "#{project}-1" do
      payload update: {
                labels: [{ add: 'bot' }, { remove: 'some' }]
              },
              fields: {
                assignee: { name: name },
                summary: 'This is a shorthand for a set operation on the summary field'
              }
    end

    sprints = client.Board.sprint board_id
    sprints['values'].each do |sprint|
      client.Sprint.delete sprint['id']
    end
    search['issues'].each do |issue|
      client.Issue.delete issue['id'] do
        params deleteSubtasks: true
      end
    end

    client.Dashboard.list
    client.Dashboard.get 10_000

    client.Permissions.list
    client.Permissions.my
    client.ApplicationProperties.list
    client.ApplicationProperties.set 'jira.search.views.default.max' do
      payload id: 'jira.search.views.default.max',
              value: 1000
    end
    client.ApplicationProperties.advanced_settings
    client.ApplicationRole.list
    client.ApplicationRole.get 'jira-software'
    client.Avatar.get 'project'
    client.Configuration.get
    client.CustomFields.get
    client.Field.list
    client.Filter.create do
      payload name: "My Filter #{project}",
              description: 'My test filter',
              jql: 'type = Bug and resolution is empty',
              favourite: true,
              editable: false
    end
    client.Filter.favourite
    client.Board.backlog 2
    client.Board.configuration 2
    client.Board.project 2
    client.Board.settings 2
    client.Board.properties 2

    client.Project.delete project.to_s
  end

  def test_random_for_obj # rubocop:disable Metrics/AbcSize,Metrics/MethodLength
    return unless env_var? 'RUJIRA_TEST'

    url = ENV.fetch('RUJIRA_URL', 'http://localhost:8080')
    client = Rujira::Client.new(url, dispatchable: false)

    project = random_name
    name = client.Myself.get.name

    project = client.Project.create do
      payload key: project.to_s,
              name: project.to_s,
              projectTypeKey: 'software',
              lead: name
    end

    require 'securerandom'

    issue_summaries = Array.new(100) { "Task #{SecureRandom.hex(3)}" }
    issue_types = %w[Task]

    commands = [
      ->(issue_id) { client.Issue.get(issue_id) },
      ->(issue_id) { client.Issue.add_comment(issue_id) { payload body: "Comment #{SecureRandom.hex(2)}" } }
    ]

    issues = []

    50.times do
      summary = issue_summaries.sample
      issue_type = issue_types.sample
      new_issue = client.Issue.create do
        payload({ fields: {
                  summary: summary,
                  issuetype: { name: issue_type },
                  project: { key: project.key }

                } })
      end

      issues << new_issue
    end

    20.times do
      commands.sample.call(issues.sample.id)
    end

    issues.map(&:delete)

    project.delete
  end

  def test_commit_style_usage # rubocop:disable Metrics/MethodLength,Metrics/AbcSize
    return unless env_var? 'RUJIRA_TEST'

    project = random_name
    url = ENV.fetch('RUJIRA_URL', 'http://localhost:8080')
    client = Rujira::Client.new(url, debug: true, dispatchable: false, commitable: true)

    name = client.Myself.get.commit['name']

    project = client.Project.create do
      payload key: project.to_s,
              name: project.to_s,
              projectTypeKey: 'software',
              lead: name
    end
    project = project.commit
    client.Project.delete(project['key']).commit
  end
end
